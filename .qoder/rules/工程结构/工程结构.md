---
trigger: manual
alwaysApply: false
---
# 工程结构文档

## 项目概述

### 项目基本信息
- **项目名称**: AI编码提示词工程
- **项目描述**: 基于AI编码实践分享文档构建的完整提示词工程体系
- **技术栈**: Spring Boot + JPA + Redis + MySQL + 微服务架构
- **目标**: 提供一套完整的AI编码提示词体系，支持三层架构开发模式

### 架构模式
采用经典的三层架构模式：
- **应用层 (Application)**: RESTful接口、DTO、控制器
- **领域层 (Domain)**: 业务逻辑、领域模型、服务接口
- **基础设施层 (Infrastructure)**: 数据访问、缓存、消息队列等

## 工程结构

```
ai-coding-prompt/
├── ai-coding-prompt/           # 根目录
│   ├── rules/                  # 规则层
│   │   └── Review需求实现检查prompt.md
│   ├── 业务层/                 # 业务逻辑层
│   │   └── 业务层prompt.md
│   ├── 应用层/                 # 应用接口层
│   │   ├── 接口定义prompt.md
│   │   ├── 接口实现prompt.md
│   │   └── 接口文档prompt.md
│   ├── 技术方案/               # 技术方案层
│   │   ├── Demo新增类-技术方案.md
│   │   ├── 修改类需求prompt.md
│   │   └── 新增类需求prompt.md
│   ├── 数据层/                 # 数据访问层
│   │   ├── 建表prompt.md
│   │   ├── 持久化prompt.md
│   │   └── 服务依赖prompt.md
│   ├── 工程结构/               # 工程结构层
│   │   ├── 工程结构.md
│   │   └── 工程结构prompt.md
│   └── readme/                 # 说明文档
│       ├── prompt使用示例.md
│       ├── prompt使用示例图.png
│       ├── prompt整体介绍.md
│       └── readme.md
├── src/                        # 源代码目录
│   ├── main/
│   │   ├── java/
│   │   │   └── com/example/demo/
│   │   │       ├── application/      # 应用层
│   │   │       │   ├── controller/   # 控制器
│   │   │       │   ├── dto/          # 数据传输对象
│   │   │       │   ├── assembler/    # 对象转换器
│   │   │       │   └── config/       # 应用配置
│   │   │       ├── domain/           # 领域层
│   │   │       │   ├── model/        # 领域模型
│   │   │       │   ├── service/      # 领域服务
│   │   │       │   ├── repository/   # 仓库接口
│   │   │       │   └── event/        # 领域事件
│   │   │       ├── infrastructure/   # 基础设施层
│   │   │       │   ├── persistence/  # 持久化实现
│   │   │       │   ├── cache/        # 缓存实现
│   │   │       │   ├── messaging/    # 消息队列
│   │   │       │   └── security/     # 安全配置
│   │   │       └── DemoApplication.java  # 启动类
│   │   └── resources/
│   │       ├── application.yml       # 主配置文件
│   │       ├── application-dev.yml   # 开发环境配置
│   │       ├── application-prod.yml  # 生产环境配置
│   │       ├── application-test.yml  # 测试环境配置
│   │       ├── logback-spring.xml    # 日志配置
│   │       ├── db/migration/         # 数据库迁移脚本
│   │       │   ├── V1__init.sql
│   │       │   └── V2__add_business.sql
│   │       └── static/               # 静态资源
│   └── test/
│       ├── java/
│       │   └── com/example/demo/
│       │       ├── application/      # 应用层测试
│       │       ├── domain/           # 领域层测试
│       │       └── infrastructure/   # 基础设施层测试
│       └── resources/
│           └── application-test.yml  # 测试配置
├── docs/                           # 项目文档
│   ├── architecture.md             # 架构设计文档
│   ├── api.md                      # API文档
│   ├── database.md                 # 数据库设计文档
│   └── deployment.md               # 部署文档
├── scripts/                        # 脚本文件
│   ├── startup.sh                  # 启动脚本
│   ├── shutdown.sh                 # 停止脚本
│   └── deploy.sh                   # 部署脚本
├── docker/                         # Docker配置
│   ├── Dockerfile
│   ├── docker-compose.yml
│   └── docker-compose.dev.yml
├── k8s/                            # Kubernetes配置
│   ├── deployment.yaml
│   ├── service.yaml
│   └── configmap.yaml
└── pom.xml                         # Maven配置文件
```

## 各层详细说明

### 1. 应用层 (Application Layer)

#### 1.1 控制器 (Controller)
```java
/**
 * 业务控制器示例
 */
@RestController
@RequestMapping("/api/v1/business")
@Tag(name = "业务管理", description = "业务管理相关接口")
@Validated
@Slf4j
public class BusinessController {
    
    private final BusinessApplicationService applicationService;
    private final BusinessAssembler assembler;
    
    /**
     * 创建业务
     */
    @PostMapping
    @Operation(summary = "创建业务")
    @ApiResponses({
        @ApiResponse(responseCode = "200", description = "创建成功"),
        @ApiResponse(responseCode = "400", description = "参数错误"),
        @ApiResponse(responseCode = "409", description = "业务名称已存在")
    })
    public ResponseEntity<ApiResponse<BusinessResponse>> createBusiness(
            @Valid @RequestBody CreateBusinessRequest request) {
        
        CreateBusinessCommand command = assembler.toCommand(request);
        BusinessDTO dto = applicationService.createBusiness(command);
        BusinessResponse response = assembler.toResponse(dto);
        
        return ResponseEntity.ok(ApiResponse.success(response));
    }
    
    /**
     * 分页查询业务
     */
    @GetMapping
    @Operation(summary = "分页查询业务")
    public ResponseEntity<ApiResponse<PageResult<BusinessResponse>>> findPage(
            @Valid BusinessQueryRequest request) {
        
        BusinessQuery query = assembler.toQuery(request);
        PageResult<BusinessDTO> page = applicationService.findPage(query);
        PageResult<BusinessResponse> response = assembler.toPageResponse(page);
        
        return ResponseEntity.ok(ApiResponse.success(response));
    }
}
```

#### 1.2 数据传输对象 (DTO)
```java
/**
 * 创建业务请求DTO
 */
@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
@Schema(description = "创建业务请求")
public class CreateBusinessRequest {
    
    @Schema(description = "业务名称", required = true, example = "新业务A")
    @NotBlank(message = "业务名称不能为空")
    @Size(max = 100, message = "业务名称长度不能超过100字符")
    private String businessName;
    
    @Schema(description = "业务类型", required = true, example = "TYPE_A")
    @NotBlank(message = "业务类型不能为空")
    @Pattern(regexp = "TYPE_[A-Z]{1}", message = "业务类型格式不正确")
    private String businessType;
    
    @Schema(description = "优先级", example = "1")
    @Min(value = 0, message = "优先级不能小于0")
    @Max(value = 999, message = "优先级不能大于999")
    private Integer priority;
    
    // 自定义校验
    @AssertTrue(message = "有效期结束时间必须晚于开始时间")
    public boolean isValidityTimeValid() {
        if (validityStartTime == null || validityEndTime == null) {
            return true;
        }
        return validityEndTime.isAfter(validityStartTime);
    }
}
```

#### 1.3 对象转换器 (Assembler)
```java
/**
 * 业务对象转换器
 */
@Component
public class BusinessAssembler {
    
    /**
     * 请求DTO -> 命令对象
     */
    public CreateBusinessCommand toCommand(CreateBusinessRequest request) {
        return CreateBusinessCommand.builder()
            .businessName(request.getBusinessName())
            .businessType(request.getBusinessType())
            .priority(request.getPriority())
            .validityStartTime(request.getValidityStartTime())
            .validityEndTime(request.getValidityEndTime())
            .extensionData(request.getExtensionData())
            .description(request.getDescription())
            .build();
    }
    
    /**
     * DTO -> 响应对象
     */
    public BusinessResponse toResponse(BusinessDTO dto) {
        return BusinessResponse.builder()
            .id(dto.getId())
            .businessCode(dto.getBusinessCode())
            .businessName(dto.getBusinessName())
            .status(dto.getStatus())
            .businessType(dto.getBusinessType())
            .priority(dto.getPriority())
            .createdAt(dto.getCreatedAt())
            .createdBy(dto.getCreatedBy())
            .build();
    }
    
    /**
     * 分页结果转换
     */
    public PageResult<BusinessResponse> toPageResponse(PageResult<BusinessDTO> page) {
        List<BusinessResponse> content = page.getContent().stream()
            .map(this::toResponse)
            .collect(Collectors.toList());
        
        return PageResult.of(content, page.getTotalElements());
    }
}
```

### 2. 领域层 (Domain Layer)

#### 2.1 领域模型 (Entity)
```java
/**
 * 业务实体
 */
@Entity
@Table(name = "t_business")
public class BusinessEntity extends BaseEntity {
    
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    @Column(name = "business_code", unique = true, nullable = false, length = 50)
    private String businessCode;
    
    @Column(name = "business_name", nullable = false, length = 100)
    private String businessName;
    
    @Enumerated(EnumType.STRING)
    @Column(name = "business_status", nullable = false, length = 20)
    private BusinessStatus status;
    
    @Column(name = "business_type", length = 30)
    private String businessType;
    
    @Column(name = "priority", columnDefinition = "int default 0")
    private Integer priority;
    
    // 业务方法
    public void activate() {
        if (this.status != BusinessStatus.DRAFT && this.status != BusinessStatus.INACTIVE) {
            throw new BusinessException("只有草稿或停用状态才能激活");
        }
        this.status = BusinessStatus.ACTIVE;
        this.activateTime = LocalDateTime.now();
        registerEvent(new BusinessActivatedEvent(this.id));
    }
    
    // 创建工厂方法
    public static BusinessEntity create(CreateBusinessCommand command) {
        BusinessEntity entity = new BusinessEntity();
        entity.businessCode = generateBusinessCode();
        entity.businessName = command.getBusinessName();
        entity.status = BusinessStatus.DRAFT;
        entity.businessType = command.getBusinessType();
        entity.priority = command.getPriority();
        return entity;
    }
}
```

#### 2.2 领域服务 (Domain Service)
```java
/**
 * 业务领域服务
 */
@DomainService
@Slf4j
public class BusinessDomainService {
    
    private final BusinessRepository repository;
    private final BusinessValidator validator;
    private final EventPublisher eventPublisher;
    
    /**
     * 创建业务
     */
    @Transactional
    public BusinessEntity createBusiness(CreateBusinessCommand command) {
        log.info("开始创建业务: {}", command.getBusinessName());
        
        // 1. 命令校验
        validator.validateCreateCommand(command);
        
        // 2. 创建实体
        BusinessEntity entity = BusinessEntity.create(command);
        
        // 3. 保存实体
        entity = repository.save(entity);
        
        // 4. 发布事件
        eventPublisher.publish(new BusinessCreatedEvent(entity.getId()));
        
        log.info("业务创建成功: {}", entity.getId());
        return entity;
    }
    
    /**
     * 激活业务
     */
    @Transactional
    public void activateBusiness(Long id) {
        BusinessEntity entity = repository.findById(id)
            .orElseThrow(() -> new BusinessException("业务不存在"));
        
        entity.activate();
        repository.save(entity);
    }
}
```

#### 2.3 仓库接口 (Repository)
```java
/**
 * 业务仓库接口
 */
@Repository
public interface BusinessRepository extends JpaRepository<BusinessEntity, Long>, JpaSpecificationExecutor<BusinessEntity> {
    
    Optional<BusinessEntity> findByBusinessCode(String businessCode);
    
    boolean existsByBusinessCode(String businessCode);
    
    List<BusinessEntity> findByStatus(BusinessStatus status);
    
    @Modifying
    @Query("UPDATE BusinessEntity b SET b.status = :status WHERE b.id = :id")
    int updateStatus(@Param("id") Long id, @Param("status") BusinessStatus status);
}
```

### 3. 基础设施层 (Infrastructure Layer)

#### 3.1 数据访问实现
```java
/**
 * 自定义仓库实现
 */
@Repository
@RequiredArgsConstructor
public class BusinessRepositoryCustom {
    
    private final EntityManager entityManager;
    
    /**
     * 复杂查询实现
     */
    public List<BusinessEntity> findWithComplexCriteria(BusinessQuery query) {
        CriteriaBuilder cb = entityManager.getCriteriaBuilder();
        CriteriaQuery<BusinessEntity> cq = cb.createQuery(BusinessEntity.class);
        Root<BusinessEntity> root = cq.from(BusinessEntity.class);
        
        List<Predicate> predicates = new ArrayList<>();
        
        if (StringUtils.isNotBlank(query.getBusinessName())) {
            predicates.add(cb.like(root.get("businessName"), "%" + query.getBusinessName() + "%"));
        }
        
        if (query.getStatus() != null) {
            predicates.add(cb.equal(root.get("status"), query.getStatus()));
        }
        
        cq.where(predicates.toArray(new Predicate[0]))
          .orderBy(cb.desc(root.get("id")));
        
        TypedQuery<BusinessEntity> typedQuery = entityManager.createQuery(cq);
        if (query.getPageSize() > 0) {
            typedQuery.setFirstResult((query.getPageNum() - 1) * query.getPageSize());
            typedQuery.setMaxResults(query.getPageSize());
        }
        
        return typedQuery.getResultList();
    }
}
```

#### 3.2 缓存实现
```java
/**
 * 缓存配置
 */
@Configuration
@EnableCaching
public class CacheConfig {
    
    @Bean
    public CacheManager cacheManager(RedisConnectionFactory factory) {
        RedisCacheConfiguration config = RedisCacheConfiguration.defaultCacheConfig()
            .entryTtl(Duration.ofMinutes(30))
            .serializeKeysWith(RedisSerializationContext.SerializationPair.fromSerializer(new StringRedisSerializer()))
            .serializeValuesWith(RedisSerializationContext.SerializationPair.fromSerializer(new GenericJackson2JsonRedisSerializer()))
            .disableCachingNullValues();
        
        return RedisCacheManager.builder(factory)
            .cacheDefaults(config)
            .withCacheConfiguration("business", 
                RedisCacheConfiguration.defaultCacheConfig()
                    .entryTtl(Duration.ofHours(1)))
            .build();
    }
}
```

## 配置文件

### 1. 主配置文件 (application.yml)
```yaml
# 主配置文件
server:
  port: 8080
  servlet:
    context-path: /demo

spring:
  application:
    name: ai-coding-demo
  
  # 数据源配置
  datasource:
    driver-class-name: com.mysql.cj.jdbc.Driver
    url: jdbc:mysql://localhost:3306/demo_db?useSSL=false&serverTimezone=UTC&characterEncoding=utf8
    username: ${DB_USERNAME:root}
    password: ${DB_PASSWORD:password}
    hikari:
      maximum-pool-size: 20
      minimum-idle: 5
      connection-timeout: 30000
      idle-timeout: 600000
      max-lifetime: 1800000

  # JPA配置
  jpa:
    hibernate:
      ddl-auto: validate
      naming:
        physical-strategy: org.hibernate.boot.model.naming.PhysicalNamingStrategyStandardImpl
    show-sql: false
    properties:
      hibernate:
        dialect: org.hibernate.dialect.MySQL8Dialect
        format_sql: true
        use_sql_comments: true
        jdbc:
          batch_size: 20
        order_inserts: true
        order_updates: true

  # Redis配置
  redis:
    host: ${REDIS_HOST:localhost}
    port: ${REDIS_PORT:6379}
    password: ${REDIS_PASSWORD:}
    database: 0
    timeout: 5000ms
    lettuce:
      pool:
        max-active: 20
        max-idle: 10
        min-idle: 0
        max-wait: 1000ms

# 日志配置
logging:
  level:
    com.example.demo: DEBUG
    org.springframework.web: INFO
    org.hibernate: WARN
  pattern:
    console: "%d{yyyy-MM-dd HH:mm:ss} [%thread] %-5level %logger{36} - %msg%n"
    file: "%d{yyyy-MM-dd HH:mm:ss} [%thread] %-5level %logger{36} - %msg%n"

# 监控配置
management:
  endpoints:
    web:
      exposure:
        include: health,info,metrics,prometheus
  endpoint:
    health:
      show-details: always
  metrics:
    export:
      prometheus:
        enabled: true
```

### 2. 开发环境配置 (application-dev.yml)
```yaml
# 开发环境配置
spring:
  # 数据源配置
  datasource:
    url: jdbc:mysql://localhost:3306/demo_db_dev?useSSL=false&serverTimezone=UTC&characterEncoding=utf8
    username: dev_user
    password: dev_password

  # Redis配置
  redis:
    host: localhost
    port: 6379
    database: 1

# 日志配置
logging:
  level:
    com.example.demo: DEBUG
    org.hibernate.SQL: DEBUG
    org.hibernate.type.descriptor.sql.BasicBinder: TRACE
  file:
    name: logs/demo-dev.log

# 开发特有配置
dev:
  tools:
    enabled: true
  hot-reload:
    enabled: true
```

## 构建和部署

### 1. Maven配置 (pom.xml)
```xml
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 
         http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>

    <parent>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-parent</artifactId>
        <version>2.7.12</version>
        <relativePath/>
    </parent>

    <groupId>com.example</groupId>
    <artifactId>ai-coding-demo</artifactId>
    <version>1.0.0</version>
    <name>AI编码提示词工程</name>
    <description>基于AI编码实践分享的完整提示词工程体系</description>

    <properties>
        <java.version>11</java.version>
        <spring-cloud.version>2021.0.7</spring-cloud.version>
    </properties>

    <dependencies>
        <!-- Spring Boot Starters -->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-web</artifactId>
        </dependency>
        
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-data-jpa</artifactId>
        </dependency>
        
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-data-redis</artifactId>
        </dependency>
        
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-validation</artifactId>
        </dependency>
        
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-actuator</artifactId>
        </dependency>
        
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-aop</artifactId>
        </dependency>
        
        <!-- 数据库驱动 -->
        <dependency>
            <groupId>mysql</groupId>
            <artifactId>mysql-connector-java</artifactId>
            <scope>runtime</scope>
        </dependency>
        
        <!-- 工具类 -->
        <dependency>
            <groupId>org.apache.commons</groupId>
            <artifactId>commons-lang3</artifactId>
        </dependency>
        
        <dependency>
            <groupId>org.projectlombok</groupId>
            <artifactId>lombok</artifactId>
            <optional>true</optional>
        </dependency>
        
        <!-- 测试依赖 -->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-test</artifactId>
            <scope>test</scope>
        </dependency>
        
        <dependency>
            <groupId>org.springframework.security</groupId>
            <artifactId>spring-security-test</artifactId>
            <scope>test</scope>
        </dependency>
    </dependencies>

    <build>
        <plugins>
            <plugin>
                <groupId>org.springframework.boot</groupId>
                <artifactId>spring-boot-maven-plugin</artifactId>
            </plugin>
            
            <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-compiler-plugin</artifactId>
                <version>3.11.0</version>
                <configuration>
                    <source>11</source>
                    <target>11</target>
                </configuration>
            </plugin>
        </plugins>
    </build>
</project>
```

### 2. Docker配置

#### Dockerfile
```dockerfile
# 多阶段构建
FROM openjdk:11-jdk-slim as builder
WORKDIR /app
COPY pom.xml .
COPY src ./src
RUN apt-get update && apt-get install -y maven
RUN mvn clean package -DskipTests

# 运行时镜像
FROM openjdk:11-jre-slim
WORKDIR /app
COPY --from=builder /app/target/*.jar app.jar
EXPOSE 8080
ENTRYPOINT ["java", "-jar", "app.jar"]
```

#### Docker Compose配置
```yaml
version: '3.8'

services:
  demo-app:
    build: .
    ports:
      - "8080:8080"
    environment:
      - SPRING_PROFILES_ACTIVE=prod
      - DB_USERNAME=prod_user
      - DB_PASSWORD=prod_password
      - REDIS_HOST=redis
    depends_on:
      - mysql
      - redis
    networks:
      - demo-network

  mysql:
    image: mysql:8.0
    environment:
      - MYSQL_ROOT_PASSWORD=root_password
      - MYSQL_DATABASE=demo_db
      - MYSQL_USER=prod_user
      - MYSQL_PASSWORD=prod_password
    ports:
      - "3306:3306"
    volumes:
      - mysql_data:/var/lib/mysql
    networks:
      - demo-network

  redis:
    image: redis:6.2-alpine
    ports:
      - "6379:6379"
    volumes:
      - redis_data:/data
    networks:
      - demo-network

volumes:
  mysql_data:
  redis_data:

networks:
  demo-network:
    driver: bridge
```

## 开发规范

### 1. 代码规范
- 遵循阿里巴巴Java开发规范
- 使用Lombok简化代码
- 统一异常处理
- 日志规范输出
- 单元测试覆盖率>80%

### 2. 文档规范
- 接口文档使用OpenAPI 3.0规范
- 代码注释完整清晰
- README文档详细说明
- 架构文档定期更新

### 3. 版本管理
- 使用Git分支管理
- 主干开发，功能分支
- 代码审查机制
- 自动化CI/CD流程

## 监控和运维

### 1. 应用监控
- Spring Boot Actuator
- Micrometer指标收集
- Prometheus + Grafana
- 自定义业务指标

### 2. 日志管理
- ELK日志收集
- 结构化日志输出
- 日志聚合分析
- 错误告警机制

### 3. 性能监控
- APM性能监控
- 数据库性能监控
- 缓存命中率监控
- 接口响应时间监控

## 部署策略

### 1. 环境划分
- **开发环境**: 本地开发调试
- **测试环境**: 功能测试验证
- **预发布环境**: 生产前验证
- **生产环境**: 正式业务环境

### 2. 部署方式
- 容器化部署(Docker)
- 容器编排(Kubernetes)
- 蓝绿部署
- 滚动升级

### 3. 回滚策略
- 版本快速回滚
- 数据库迁移回滚
- 配置变更回滚
- 灰度发布策略